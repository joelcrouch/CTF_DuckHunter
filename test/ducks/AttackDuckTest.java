package ducks;

import battlecode.common.*;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

public class AttackDuckTest {
    RobotController mockRc;
    AttackDuck attackDuck;

    @Before
    public void setUp() {
        mockRc = Mockito.mock(RobotController.class);
        attackDuck = new AttackDuck(mockRc);
    }

    @Test
    public void testSanity() {
        assertEquals(2, 1 + 1);
    }

    @Test
    public void testIsDivisibleBySeven() {
        // Test cases where the ID is divisible by 7
        assertTrue(attackDuck.isDivisibleBySeven(7));
        assertTrue(attackDuck.isDivisibleBySeven(14));
        assertTrue(attackDuck.isDivisibleBySeven(21));

        // Test cases where the ID is not divisible by 7
        assertFalse(attackDuck.isDivisibleBySeven(1));
        assertFalse(attackDuck.isDivisibleBySeven(8));
        assertFalse(attackDuck.isDivisibleBySeven(15));
    }

    @Test
    public void testMoveRandomly() throws GameActionException {
        // Setup mock behavior
        when(mockRc.canMove(any(Direction.class))).thenReturn(true);

        // Call the method under test
        attackDuck.moveRandomly();

        // Verify that the robot moved in a valid direction
        verify(mockRc, atLeastOnce()).move(any(Direction.class));
    }

    @Test
    public void testMoveToTargetMapLocation() throws GameActionException {
        // Setup mock behavior
        MapLocation currentLocation = new MapLocation(0, 0);
        MapLocation targetLocation = new MapLocation(3, 3);
        Direction toTarget = currentLocation.directionTo(targetLocation);

        when(mockRc.getLocation()).thenReturn(currentLocation);
        when(mockRc.canMove(toTarget)).thenReturn(true);

        // Call the method under test
        attackDuck.moveToTargetMapLocation(targetLocation);

        // Verify that the robot moved towards the target location
        verify(mockRc).move(toTarget);

        // Test the case where the direct path is blocked
        when(mockRc.canMove(toTarget)).thenReturn(false);
        when(mockRc.canMove(any(Direction.class))).thenReturn(true);

        // Call the method under test again
        attackDuck.moveToTargetMapLocation(targetLocation);

        // Verify that the robot moved randomly
        verify(mockRc, atLeastOnce()).move(any(Direction.class));
    }

    @Test
    public void testCalculateOppositeSpawnLocations() throws GameActionException {
        // Setup mock behavior
        MapLocation[] allySpawnLocations = {
                new MapLocation(1, 1),
                new MapLocation(2, 2),
                new MapLocation(3, 3)
        };
        int mapWidth = 10;
        int mapHeight = 10;

        when(mockRc.getAllySpawnLocations()).thenReturn(allySpawnLocations);
        when(mockRc.getMapWidth()).thenReturn(mapWidth);
        when(mockRc.getMapHeight()).thenReturn(mapHeight);

        // Call the method under test
        MapLocation[] oppositeSpawnLocations = attackDuck.calculateOppositeSpawnLocations();

        // Expected opposite spawn locations
        MapLocation[] expectedOppositeSpawnLocations = {
                new MapLocation(8, 8),
                new MapLocation(7, 7),
                new MapLocation(6, 6)
        };

        // Verify the results
        assertArrayEquals(expectedOppositeSpawnLocations, oppositeSpawnLocations);
    }

    @Test
    public void testMoveToTargetMapLocation_CannotMove() throws GameActionException {
        // Setup mock behavior
        MapLocation currentLocation = new MapLocation(0, 0);
        MapLocation targetLocation = new MapLocation(3, 3);
        Direction toTarget = currentLocation.directionTo(targetLocation);

        when(mockRc.getLocation()).thenReturn(currentLocation);
        when(mockRc.canMove(toTarget)).thenReturn(false);
        when(mockRc.canMove(any(Direction.class))).thenReturn(true);

        // Call the method under test
        attackDuck.moveToTargetMapLocation(targetLocation);

        // Verify that the robot moved randomly
        verify(mockRc, atLeastOnce()).move(any(Direction.class));
    }

    @Test
    public void testMoveToTargetMapLocation_NoValidMove() throws GameActionException {
        // Setup mock behavior
        MapLocation currentLocation = new MapLocation(0, 0);
        MapLocation targetLocation = new MapLocation(3, 3);
        Direction toTarget = currentLocation.directionTo(targetLocation);

        when(mockRc.getLocation()).thenReturn(currentLocation);
        when(mockRc.canMove(toTarget)).thenReturn(false);
        when(mockRc.canMove(any(Direction.class))).thenReturn(false);

        // Call the method under test
        attackDuck.moveToTargetMapLocation(targetLocation);

        // Verify that the robot did not move
        verify(mockRc, never()).move(any(Direction.class));
    }

    @Test
    public void testAttackLowestHealthRobot() throws GameActionException {
        // Setup mock behavior
        RobotInfo robot1 = new RobotInfo(1, Team.A, 50, new MapLocation(1, 1), false, 1, 1, 1);
        RobotInfo robot2 = new RobotInfo(2, Team.A, 30, new MapLocation(1, 1), false, 1, 1, 1);
        RobotInfo robot3 = new RobotInfo(3, Team.A, 40, new MapLocation(1, 1), false, 1, 1, 1);

        RobotInfo[] enemyRobots = { robot1, robot2, robot3 };
        when(mockRc.getTeam()).thenReturn(Team.A);
        when(mockRc.senseNearbyRobots(-1, mockRc.getTeam().opponent())).thenReturn(enemyRobots);
        when(mockRc.canAttack(any(MapLocation.class))).thenReturn(true);

        // Call the method under test
        attackDuck.attackLowestHealthRobot(enemyRobots);

        // Verify that the robot attacked the lowest health robot
        verify(mockRc).attack(robot2.getLocation());
    }

    @Test
    public void testMoveToFlagsLocation() throws GameActionException {
        // Setup mock flag info
        MapLocation currentLocation = new MapLocation(0, 0);
        MapLocation flagLocation = new MapLocation(5, 5);
        Direction toTarget = currentLocation.directionTo(flagLocation);

        when(mockRc.getLocation()).thenReturn(currentLocation);
        when(mockRc.canMove(toTarget)).thenReturn(true);

        // Call the method under test
        attackDuck.moveToTargetMapLocation(flagLocation);

        // Verify that the robot moved towards the target location
        verify(mockRc).move(toTarget);

        // Test the case where the direct path is blocked
        when(mockRc.canMove(toTarget)).thenReturn(false);
        when(mockRc.canMove(any(Direction.class))).thenReturn(true);

        // Call the method under test again
        attackDuck.moveToTargetMapLocation(flagLocation);

        // Verify that the robot moved randomly
        verify(mockRc, atLeastOnce()).move(any(Direction.class));
    }

    // @Test
    // public void testMovingDecision_DivisibleBySeven() throws GameActionException {
    //     // Setup mock behavior
    //     when(mockRc.getID()).thenReturn(7);
    //     doNothing().when(attackDuck).exploreMove();

    //     // Call the method under test
    //     attackDuck.movingDecision();

    //     // Verify that exploreMove was called
    //     verify(attackDuck, times(1)).exploreMove();
    //     verify(attackDuck, times(0)).moveToOppositeSpawnLocation();
    // }

    // @Test
    // public void testMovingDecision_NotDivisibleBySeven() throws GameActionException {
    //     // Setup mock behavior
    //     when(mockRc.getID()).thenReturn(8);
    //     doNothing().when(attackDuck).moveToOppositeSpawnLocation();

    //     // Call the method under test
    //     attackDuck.movingDecision();

    //     // Verify that moveToOppositeSpawnLocation was called
    //     verify(attackDuck, times(1)).moveToOppositeSpawnLocation();
    //     verify(attackDuck, times(0)).exploreMove();
    // }
   
}
